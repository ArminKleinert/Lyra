;;;;;
;;;;; SECTION File loading

; Load, parse and execute a lyra-source file
(define (load! f)
  (eval! (parse (slurp! f))))

(define require! load!)
(define import! load!)

;;;;;
;;;;; SECTION Important imports
;;;;;

(load! "type.lyra")

;;;;;
;;;;; SECTION Type definitions
;;;;;

(define nil-type    (add-lyra-type!))
(define cons-type   (add-lyra-type!))
(define int-type    (add-lyra-type!))
(define float-type  (add-lyra-type!))
(define bool-type   (add-lyra-type!))
(define string-type (add-lyra-type!))
(define vector-type (add-lyra-type!))
(define symbol-type (add-lyra-type!))

(define type-match? p=)
(define (null? e)   (type-match? (lyra-type-id e) nil-type))
(define (cons? e)   (type-match? (lyra-type-id e) cons-type))
(define (int? e)    (type-match? (lyra-type-id e) int-type))
(define (float? e)  (type-match? (lyra-type-id e) float-type))
(define (bool? e)   (type-match? (lyra-type-id e) bool-type))
(define (string? e) (type-match? (lyra-type-id e) string-type))
(define (vector? e) (type-match? (lyra-type-id e) vector-type))
(define (symbol? e) (type-match? (lyra-type-id e) symbol-type))

(add-basics! nil-type    string p=)
(add-basics! cons-type   string p=)
(add-basics! int-type    string p=)
;(add-basics! float-type  string p=)
;(add-basics! bool-type   string p=)
;(add-basics! string-type string p=)
;(add-basics! vector-type string p=)
;(add-basics! symbol-type string p=)

;;;;;
;;;;; SECTION Basic operations and operators
;;;;;

; Boolean and
(def-macro (and x y)
  (list 'if x y #f))

; Boolean or
(def-macro (or x y)
  (list 'if x #t y))

; Negate boolean
(define (not x)
  (if x #f #t))

; Execute 2 commands in order. The second argument is returned.
(define (begin e0 e1)
  (if e0 e1 e1))

; This macro ignores its body and returns nil.
(def-macro (comment & e)
  )

(define (atom? e)
  (bit-match? 0b1011110 (lyra-type-id e)))

(define (number? e)
  (or (int? e) (float? e)))

; Operators. These can later be expanded for other types.
; Maybe we could add conses or vectors or strings together?
(define = p=)
(define eq? p=)
(define eql? p=)
(define (not= e0 e1) (not (eq? e0 e1)))
(define < p<)
(define > p>)
(define + p+)
(define - p-)
(define * p*)
(define / p/)
(define % p%)
(define & p&)
(define | p|)
(define ^ p^)
(define bit-xor p^)
(define << p<<)
(define >> p>>)

(define (<= x y) (or (< x y) (= x y)))
(define (>= x y) (or (> x y) (= x y)))

(define (max n0 n1) (if (> n0 n1) n0 n1))
(define (min n0 n1) (if (> n0 n1) n1 n0))

(define (abs n) (if (< n 0) (- 0 n) n))

(define (even? n)
  (= (% n 2) 0))

(define (odd? n)
  (not= (% n 2) 0))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

;;;;;
;;;;; SECTION String transformation
;;;;;

; Finds the right string transformation function for the given element
; and tries to coonvert it to a string.
(define (to-string e)
  (let* (f (get-type-function e 'to-string))
    ((if f f string) e)))

;;;;;
;;;;; SECTION Simple IO
;;;;;

; Read a line from stdin.
(define (read!)
  (sread! stdin))

; Prints a string to stdout.
(define (print! e)
  (sprint! stdout e to-string))

; Prints a string to stdout followed by a new line.
(define (println! e)
  (sprint! stdout e to-string)
  (sprint! stdout "\n"))

; Prints the elements of a list, separated by newlines.
(define (printall! cs)
  (if (empty? cs)
    '()
    (begin
      (println! (car cs) to-string)
      (printall! (cdr cs)))))

;;;;;
;;;;; SECTION Lists and vectors
;;;;;

(define nil '())

; Check a sequence for emptyness
(define (empty? l)
  (if (vector? l)
    (= (vector-size l) 0)
    (or (atom? l) (null? l))))

;;; SUBSECT: Accessors for sequences

(define (first c) (if (vector? c) (vector-get c 0) (car c)))
(define (second c) (if (vector? c) (vector-get c 1) (car (cdr c))))
(define (ffirst c) (first (first c)))
(define (sfirst c) (second (first c)))
(define (rfirst c) (rest (first c)))
(define (third c) (if (vector? c) (vector-get c 2) (car (cdr (cdr c)))))
(define (fourth c) (if (vector? c) (vector-get c 3) (car (cdr (cdr (cdr c))))))
(define (rest c) (if (vector? c) (cpy-vector-range c 1 (dec (vector-size c))) (cdr c)))

; Get element by index (Cons)
(define (list-nth xs index)
  (if xs
    (if (= index 0)
      (car xs)
      (list-nth (cdr xs) (- index 1)))
    '()))

; Get element by index (General)
(define (nth xs index)
  (if (vector? xs)
    (vector-get xs index)
    (list-nth xs index)))

; at is an alias for nth
(define at nth)

; car and cdr variants. Prefer first, second, ... if possible
(define (caar x)    (car (car x)))
(define (cadr x)    (car (cdr x)))
(define (cdar x)    (cdr (car x)))
(define (cddr x)    (cdr (cdr x)))
(define (caaar x)   (car (car (car x))))
(define (caadr x)   (car (car (cdr x))))
(define (cadar x)   (car (cdr (car x))))
(define (caddr x)   (car (cdr (cdr x))))
(define (cdaar x)   (cdr (car (car x))))
(define (cdadr x)   (cdr (car (cdr x))))
(define (cddar x)   (cdr (cdr (car x))))
(define (cdddr x)   (cdr (cdr (cdr x))))
(define (caaaar x)  (car (car (car (car x)))))
(define (caaadr x)  (car (car (car (cdr x)))))
(define (caadar x)  (car (car (cdr (car x)))))
(define (caaddr x)  (car (car (cdr (cdr x)))))
(define (cadaar x)  (car (cdr (car (car x)))))
(define (cadadr x)  (car (cdr (car (cdr x)))))
(define (caddar x)  (car (cdr (cdr (car x)))))
(define (cadddr x)  (car (cdr (cdr (cdr x)))))
(define (cdaaar x)  (cdr (car (car (car x)))))
(define (cdaadr x)  (cdr (car (car (cdr x)))))
(define (cdadar x)  (cdr (car (cdr (car x)))))
(define (cdaddr x)  (cdr (car (cdr (cdr x)))))
(define (cddaar x)  (cdr (cdr (car (car x)))))
(define (cddadr x)  (cdr (cdr (car (cdr x)))))
(define (cdddar x)  (cdr (cdr (cdr (car x)))))
(define (cddddr x)  (cdr (cdr (cdr (cdr x)))))

; Length of a sequence
(define (length c)
  (cond ((vector? c) (vector-size c))
        ((cons? c) (let* (addone (lambda (n m) (inc n)))
                    (foldl addone 0 c)))
        (#t 0)))

;;; SUBSECT: Fold: Iterate over a sequence and apply an operation.

; Fold left (Vector)

(define (vfoldl f start v)
  (vector-iterate
    v start
    (lambda (acc e i) (f acc e))))

; Fold left (Cons)
(define (cfoldl f start coll)
  (if (empty? coll)
    start
    (cfoldl f (f start (first coll)) (rest coll))))

; Fold left (General)
(define (foldl f start coll)
  (if (vector? coll) (vfoldl f start coll) (cfoldl f start coll)))

; Reduce is just an alias for foldl.
(define reduce foldl)

; Fold right
(define (foldr f start coll)
  (if (empty? coll)
    start
    (f (first coll) (foldr f start (rest coll)))))

;;; SUBSECT: Map (apply a function on each element)

; map for vectors
(define (map-vector f v)
  (vector-iterate
    v (cleared-vector v)
    (lambda (acc e i) (vector-append! acc (f e)))))

; map for conses
(define (map-list f xs)
  (if (empty? xs)
    '()
    (cons (f (car xs)) (map f (cdr xs)))))

; Executes a function f on each element of a list xs
; and returns a new list.
(define (map f xs)
  (if (vector? xs)
    (map-vector f xs)
    (map-list f xs)))

; Like map for conses, but works in place.
(define (map! f xs)
  (if (empty? xs)
    xs
    (begin
      (set-car! xs (f (first xs))
      (map! f (rest xs))))))

;;; SUBSECT: Filter a list xs by a predicate f.

(define (filter-vector f v)
  (vector-iterate v (cleared-vector v)
    (lambda (acc e i) (if (f e) (vector-append! acc e) acc))))
    
(define (filter-list f xs)
  (if (empty? xs)
    '()
    (if (f (car xs))
      (cons (car xs) (filter f (cdr xs)))
      (filter-list f (cdr xs)))))

(define (filter f xs)
  (if (vector? xs) (filter-vector f xs) (filter-list f xs)))

;;; SUBSECT: Copying

(define (cpy-list c)
  (foldr cons '() c))

(define (cpy-vector v)
  (cpy-vector-range v 0 (dec (vector-size v))))

(define (cleared-vector v)
  (pvector (lyra-type-id v)))

; Copies a vector and keeps its type-id (if overridden) in place.

(define (cpy-vector-range v start end)
  (vector-iterate v (pvector (lyra-type-id v))
    (lambda (acc e i) (if (or (< i start) (> i end)) acc (vector-append! acc e)))))


;;; SUBSECT: Appending lists and vectors

; Appends a list to another.
; The complexity depends on the length of the first list.
(define (append-list c0 c1)
  (if (empty? c0)
    c1
    (cons (first c0) (append-list (rest c0) c1))))

; Appends a vector to another.
(define (vector-append-multi v0 v1)
  (vector-iterate v1 (cpy-vector v0)
    (lambda (acc e i) (vector-append! acc e))))

(define (append c0 c1)
  (if (vector? c0)
    (vector-append-multi c0 c1)
    (append-list c0 c1)))
    
;;; SUBSECT reversal
    
(define (reverse xs)
  (foldl
    (lambda (res e) (cons e res))
    '() xs))

;;; SUBSECT Conversion between lists and vectors.

(define (list->vector ls)
  (foldl (lambda (v x) (vector-append! v x))
         (vector) ls))

(define (vector->list v)
  (let* (iter (lambda (i nl)
          (if (< i 0)
            nl
            (iter (dec i)
              (cons (vector-get v i) nl)))))
    (iter (dec (vector-size v)) '())))

;;; SUBSECT Searching lists and vectors by predicate

(define (list-find-first f l)
  (cond ((empty? l) '())
        ((f (car l)) (car l))
        (#t (list-find-first f (rest l)))))

; Suboptimal: vector-iterate has no way to stop early.
(define (vector-find-first f v)
  (vector-iterate v '()
    (lambda (res e i)
      (cond ((not (null? res)) res)
            ((f e) e)
            #t res))))

; Find first element which matches a predicate p
(define (find-first p c)
  (if (vector? c)
    (vector-find-first p c)
    (list-find-first p c)))

(define (associated key c)
  (let* (pair (find-first (lambda (e) (= (first e) key)) c))
    (if pair (cdr pair) '())))

(define (remove-associations key c)
  (filter (lambda (e) (not= (first e) key)) c))

;;;;;
;;;;; SECTION: Interpreter hacking! Not safe for normal use!
;;;;;

; Do not call directly. This should only be called by deprioritise!.
(define (deprioritise-helper! env sym val found)
  (if (empty? env)
    '()
    (if (empty? (cdr env))
      (if found
        (if (= (car (car env)) sym)
          (set-cdr! (car env) val)
          (set-cdr! env (list (cons sym val))))
        '())
      (if (= (car (car env)) sym)
        (if found
          (begin
            (set-car! (car env) (car (cdr env)))
            (set-cdr! (car env) (cdr (cdr env))))
          (let* (v (cdr (car env)))
            (set-car! env (car (cdr env)))
            (set-cdr! env (cdr (cdr env)))
            (deprioritise-helper! (cdr env) sym v #t)))
        (deprioritise-helper! (cdr env) sym val found)))))

; Find symbol in global env and move it to the end
; Example:
;   (define nothing '())
;   (println! (index-in-env! 'nothing)) => 0
;   (deprioritise! 'nothing)
;   (println! (index-in-env! 'nothing)) => 86
(define (deprioritise! sym)
  (deprioritise-helper! (global-env!) sym '() #f))

(define (index-in-env-helper! sym env i)
  (if (empty? env)
    -1
    (if (= (car (car env)) sym)
      i
      (index-in-env-helper! sym (cdr env) (inc i)))))

; Find the index of a symbol in the global environment.
; Indexing starts at 0. If the symbol could not be found,
; -1 is returned.
(define (index-in-env! sym)
  (index-in-env-helper! sym (global-env!) 0))

;;;;;
;;;;; SECTION: Utilities
;;;;;

; Execute a function with no arguments n times. If n is
; less than 1, the function is still executed at least once.
(define (times n f)
  (if (<= n 1)
    (f)
    (begin
      (f)
      (times (dec n) f))))

; Takes 1 argument and returns it.
(define (id e)
  e)

; Bad, bad, bad
(define (hash-code-helper e)
  (cond ((string? e) (p-hash e))
         ((number? e) (int e))
         ((or (cons? e) (vector? e))
            (foldl
              (lambda (res n) (* res (hash-code n)))
              32 e))
         ((bool? e) (if e 111 -111))
         ((symbol? e) (+ (<< (p-hash (string e)) 1) 1))
         (#t 0)))

; Calculate the hash-code of an object.
(define (hash-code e)
  (let* (code (hash-code-helper e))
    ;(bit-xor code (>> code 10))
    code))

;;;;;
;;;;; SECTION : Tests
;;;;;

(define (add e0 e1) (+ e0 e1))
(println! (add 1 1))
(println! (= 1 1))
(println! (not (= 1 1)))
(println! (not= 1 1))
(println! "")
(println! (= 2 1))
(println! (not (= 2 1)))
(println! (not= 2 1))
(println! "")
(println! (= 1 2))
(println! (not (= 1 2)))
(println! (not= 1 2))

(comment

(define (range n m acc)
  (if (> n m)
    acc
    (range (inc n) m (vector-append! acc n))))

(let* (v (range 0 100 (vector)))
  (println! (measure 100 (lambda () (filter (lambda (e) (even? e)) v))))
  (let* (l (vector->list v))
    (println! (measure 100  (lambda () (filter (lambda (e) (even? e)) l))))))

(println! (reverse (list 1 2 3 4 5)))

(println! (hash-code "abc"))
(println! (hash-code 'abc))
(println! (hash-code 198))
(println! (hash-code 891.0))
(println! (hash-code (list 1 2 3 4)))
(println! (hash-code (vector 1 2 3 4 5)))
(println! (hash-code #t))
(println! (hash-code #f))

(let ((v (vector 1 2 3 4 5))
      (nv (cpy-vector v))
      (l (list 1 2 3 4 5))
      (nl (cpy-list l)))
  (println! v)
  (println! nv)
  (vector-append! v 1)
  (println! v)
  (println! nv)
  (println! "")
  (println! l)
  (println! nl)
  (set-car! l 15)
  (println! l)
  (println! nl)
  )

(let* (v (vector 1 2 3 4 5))
  (println! (vector? v))
  (println! (map-vector inc v))
  (println! (filter-vector odd? v))
  (println! (append (vector 1 2 3) (vector 3 4 5)))
  (println! (rest v))
  (println! (foldl + 0 v))
  (println! (even? (vector-get v 1)))
  (println! (even? (vector-get v 4)))
  )

(println! (hash-code 8))
(println! (hash-code "abc"))
(println! (hash-code '()))
(println! (hash-code #t))
(println! (hash-code #f))
(println! (hash-code (vector 1 2 3)))
(println! (hash-code (vector 1 2 (cons 3 4))))
(println! (hash-code (list 1 2 3)))
(println! (hash-code (list 1 2 (cons 3 4))))

)


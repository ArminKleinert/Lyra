;;;;;
;;;;; SECTION File loading

; Load, parse and execute a lyra-source file
(define (load! f)
  (eval! (parse (slurp! f))))

(define require! load!)
(define import! load!)

;;;;;
;;;;; SECTION Basic operations and operators
;;;;;

(define (null? e)   (= (lyra-type-id e) 0))
(define (cons? e)   (bit-match? 0b00000001 (lyra-type-id e)))
(define (int? e)    (bit-match? 0b00000010 (lyra-type-id e)))
(define integer? int?)
(define (float? e)  (bit-match? 0b00000100 (lyra-type-id e)))
(define (bool? e)   (bit-match? 0b00001000 (lyra-type-id e)))
(define (string? e) (bit-match? 0b00010000 (lyra-type-id e)))
(define (vector? e) (bit-match? 0b00100000 (lyra-type-id e)))
(define (symbol? e) (bit-match? 0b01000000 (lyra-type-id e)))

; Boolean and
(def-macro (and x y)
  (list 'if x y #f))

; Boolean or
(def-macro (or x y)
  (list 'if x #t y))

; Negate boolean
(define (not x)
  (if x #f #t))

; Execute 2 commands in order. The second argument is returned.
(define (begin e0 e1)
  (if e0 e1 e1))

; This macro ignores its body and returns nil.
(def-macro (comment & e)
  )

(define (atom? e)
  (bit-match? 0b1011110 (lyra-type-id e)))

(define (number? e)
  (or (int? e) (float? e)))

; Operators. These can later be expanded for other types.
; Maybe we could add conses or vectors or strings together?
(define = p=)
(define eq? p=)
(define eql? p=)
(define (not= e0 e1) (not (eq? e0 e1)))
(define < p<)
(define > p>)
(define + p+)
(define - p-)
(define * p*)
(define / p/)
(define % p%)
(define & p&)
(define | p|)
(define ^ p^)
(define bit-xor p^)
(define << p<<)
(define >> p>>)

(define (<= x y) (or (< x y) (= x y)))
(define (>= x y) (or (> x y) (= x y)))

(define (max n0 n1) (if (> n0 n1) n0 n1))
(define (min n0 n1) (if (> n0 n1) n1 n0))

(define (abs n) (if (< n 0) (- 0 n) n))

(define (even? n)
  (= (% n 2) 0))

(define (odd? n)
  (not= (% n 2) 0))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

;;;;;
;;;;; SECTION String transformation
;;;;;

(define LYRA-STRING-TRANSFORMERS (vector))

(define (add-lyra-string-transformer! type-mask fn)
  (vector-append! LYRA-STRING-TRANSFORMERS (cons type-mask fn)))

; Try to find the first fitting transformation function in
; LYRA-STRING-TRANSFORMERS using bit-match?. If non are found,
; the primitive string function is returned.
(define (get-lyra-string-transformer-by-type-id-fallback type-id)
  (let* (iter (lambda (i)
          (cond ((< i 0) string) ; Not found, fall back to native implementation.
                ((bit-match? type-id (car (vector-get LYRA-STRING-TRANSFORMERS i)))
                 (cdr (vector-get LYRA-STRING-TRANSFORMERS i)))
                (#t (iter (dec i))))))
    (iter (dec (vector-size LYRA-STRING-TRANSFORMERS)))))

; Try to find the first fitting transformation function in 
; LYRA-STRING-TRANSFORMERS using = on the type-id and the ids
; of all the transformation-functions.
(define (get-lyra-string-transformer-by-type-id type-id)
  (let ((iter (lambda (i)
          (cond ((= i (vector-size LYRA-STRING-TRANSFORMERS)) '())
                ((= type-id (car (vector-get LYRA-STRING-TRANSFORMERS i)))
                 (cdr (vector-get LYRA-STRING-TRANSFORMERS i)))
                (#t (iter (inc i))))))
        (transformer (iter 0)))
    (if transformer
      transformer
      (get-lyra-string-transformer-by-type-id-fallback type-id))))

(add-lyra-string-transformer! 0b00000000 (lambda (e) "")) ; Nil
(add-lyra-string-transformer! 0b00000001 string) ; Cons
(add-lyra-string-transformer! 0b00000010 string) ; Int
(add-lyra-string-transformer! 0b00000100 string) ; Float
(add-lyra-string-transformer! 0b00001000 (lambda (b) (if b "#t" "#f"))) ; Bool
(add-lyra-string-transformer! 0b00010000 string) ; String
(add-lyra-string-transformer! 0b00100000 string) ; Vector
(add-lyra-string-transformer! 0b01000000 string) ; Symbol

; Finds the right string transformation function for the given element
; and tries to coonvert it to a string.
(define (to-string e)
  (let* (f (get-lyra-string-transformer-by-type-id (lyra-type-id e)))
    (f e)))

;;;;;
;;;;; SECTION Simple IO
;;;;;

; Read a line from stdin.
(define (read!)
  (sread! stdin))

; Prints a string to stdout.
(define (print! e)
  (sprint! stdout (to-string e)))

; Prints a string to stdout followed by a new line.
(define (println! e)
  (sprint! stdout e to-string)
  (sprint! stdout "\n"))

; Prints the elements of a list, separated by newlines.
(define (printall! cs)
  (if (empty? cs)
    '()
    (begin
      (println! (car cs) to-string)
      (printall! (cdr cs)))))

;;;;;
;;;;; SECTION Lists and vectors
;;;;;

(define nil '())

; Check a sequence for emptyness
(define (empty? l)
  (if (vector? l)
    (= (vector-size l) 0)
    (or (atom? l) (null? l))))

;;; SUBSECT: Accessors for sequences

(define (first c) (if (vector? c) (vector-get c 0) (car c)))
(define (second c) (if (vector? c) (vector-get c 1) (car (cdr c))))
(define (ffirst c) (first (first c)))
(define (sfirst c) (second (first c)))
(define (rfirst c) (rest (first c)))
(define (third c) (if (vector? c) (vector-get c 2) (car (cdr (cdr c)))))
(define (fourth c) (if (vector? c) (vector-get c 3) (car (cdr (cdr (cdr c))))))
(define (rest c) (if (vector? c) (cpy-vector-range c 1 (dec (vector-size c))) (cdr c)))

; Get element by index (Cons)
(define (list-nth xs index)
  (if xs
    (if (= index 0)
      (car xs)
      (list-nth (cdr xs) (- index 1)))
    '()))

; Get element by index (General)
(define (nth xs index)
  (if (vector? xs)
    (vector-get xs index)
    (list-nth xs index)))

; at is an alias for nth
(define at nth)

; car and cdr variants. Prefer first, second, ... if possible
(define (caar x)    (car (car x)))
(define (cadr x)    (car (cdr x)))
(define (cdar x)    (cdr (car x)))
(define (cddr x)    (cdr (cdr x)))
(define (caaar x)   (car (car (car x))))
(define (caadr x)   (car (car (cdr x))))
(define (cadar x)   (car (cdr (car x))))
(define (caddr x)   (car (cdr (cdr x))))
(define (cdaar x)   (cdr (car (car x))))
(define (cdadr x)   (cdr (car (cdr x))))
(define (cddar x)   (cdr (cdr (car x))))
(define (cdddr x)   (cdr (cdr (cdr x))))
(define (caaaar x)  (car (car (car (car x)))))
(define (caaadr x)  (car (car (car (cdr x)))))
(define (caadar x)  (car (car (cdr (car x)))))
(define (caaddr x)  (car (car (cdr (cdr x)))))
(define (cadaar x)  (car (cdr (car (car x)))))
(define (cadadr x)  (car (cdr (car (cdr x)))))
(define (caddar x)  (car (cdr (cdr (car x)))))
(define (cadddr x)  (car (cdr (cdr (cdr x)))))
(define (cdaaar x)  (cdr (car (car (car x)))))
(define (cdaadr x)  (cdr (car (car (cdr x)))))
(define (cdadar x)  (cdr (car (cdr (car x)))))
(define (cdaddr x)  (cdr (car (cdr (cdr x)))))
(define (cddaar x)  (cdr (cdr (car (car x)))))
(define (cddadr x)  (cdr (cdr (car (cdr x)))))
(define (cdddar x)  (cdr (cdr (cdr (car x)))))
(define (cddddr x)  (cdr (cdr (cdr (cdr x)))))

; Length of a sequence
(define (length c)
  (cond ((vector? c) (vector-size c))
        ((cons? c) (let* (addone (lambda (n m) (inc n)))
                    (foldl addone 0 c)))
        (#t 0)))

;;; SUBSECT: Fold: Iterate over a sequence and apply an operation.

; Fold left (Vector)

(define (vfoldl f start v)
  (vector-iterate
    v start
    (lambda (acc e i) (f acc e))))

; Fold left (Cons)
(define (cfoldl f start coll)
  (if (empty? coll)
    start
    (cfoldl f (f start (first coll)) (rest coll))))

; Fold left (General)
(define (foldl f start coll)
  (if (vector? coll) (vfoldl f start coll) (cfoldl f start coll)))

; Reduce is just an alias for foldl.
(define reduce foldl)

; Fold right
(define (foldr f start coll)
  (if (empty? coll)
    start
    (f (first coll) (foldr f start (rest coll)))))

;;; SUBSECT: Map (apply a function on each element)

; map for vectors
(define (map-vector f v)
  (vector-iterate
    v (cleared-vector v)
    (lambda (acc e i) (vector-append! acc (f e)))))

; map for conses
(define (map-list f xs)
  (if (empty? xs)
    '()
    (cons (f (car xs)) (map f (cdr xs)))))

; Executes a function f on each element of a list xs
; and returns a new list.
(define (map f xs)
  (if (vector? xs)
    (map-vector f xs)
    (map-list f xs)))

; Like map for conses, but works in place.
(define (map! f xs)
  (if (empty? xs)
    xs
    (begin
      (set-car! xs (f (first xs))
      (map! f (rest xs))))))

;;; SUBSECT: Filter a list xs by a predicate f.

(define (filter-vector f v)
  (vector-iterate v (cleared-vector v)
    (lambda (acc e i) (if (f e) (vector-append! acc e) acc))))
    
(define (filter-list f xs)
  (if (empty? xs)
    '()
    (if (f (car xs))
      (cons (car xs) (filter f (cdr xs)))
      (filter-list f (cdr xs)))))

(define (filter f xs)
  (if (vector? xs) (filter-vector f xs) (filter-list f xs)))

;;; SUBSECT: Copying

(define (cpy-list c)
  (foldr cons '() c))

(define (cpy-vector v)
  (cpy-vector-range v 0 (dec (vector-size v))))

(define (cleared-vector v)
  (pvector (lyra-type-id v)))

; Copies a vector and keeps its type-id (if overridden) in place.

(define (cpy-vector-range v start end)
  (vector-iterate v (pvector (lyra-type-id v))
    (lambda (acc e i) (if (or (< i start) (> i end)) acc (vector-append! acc e)))))


;;; SUBSECT: Appending lists and vectors

; Appends a list to another.
; The complexity depends on the length of the first list.
(define (append-list c0 c1)
  (if (empty? c0)
    c1
    (cons (first c0) (append-list (rest c0) c1))))

; Appends a vector to another.
(define (vector-append-multi v0 v1)
  (vector-iterate v1 (cpy-vector v0)
    (lambda (acc e i) (vector-append! acc e))))

(define (append c0 c1)
  (if (vector? c0)
    (vector-append-multi c0 c1)
    (append-list c0 c1)))
    
;;; SUBSECT reversal
    
(define (reverse xs)
  (foldl
    (lambda (res e) (cons e res))
    '() xs))

;;; SUBSECT Conversion between lists and vectors.

(define (list->vector ls)
  (foldl (lambda (v x) (vector-append! v x))
         (vector) ls))

; TODO with vector-iterate
(define (vector->list v)
  (let* (iter (lambda (i nl)
          (if (< i 0)
            nl
            (iter (dec i)
              (cons (vector-get v i) nl)))))
    (iter (dec (vector-size v)) '())))

;;;;;
;;;;; SECTION: Interpreter hacking! Not safe for normal use!
;;;;;

; Do not call directly. This should only be called by deprioritise!.
(define (deprioritise-helper! env sym val found)
  (if (empty? env)
    '()
    (if (empty? (cdr env))
      (if found
        (if (= (car (car env)) sym)
          (set-cdr! (car env) val)
          (set-cdr! env (list (cons sym val))))
        '())
      (if (= (car (car env)) sym)
        (if found
          (begin
            (set-car! (car env) (car (cdr env)))
            (set-cdr! (car env) (cdr (cdr env))))
          (let* (v (cdr (car env)))
            (set-car! env (car (cdr env)))
            (set-cdr! env (cdr (cdr env)))
            (deprioritise-helper! (cdr env) sym v #t)))
        (deprioritise-helper! (cdr env) sym val found)))))

; Find symbol in global env and move it to the end
; Example:
;   (define nothing '())
;   (println! (index-in-env! 'nothing)) => 0
;   (deprioritise! 'nothing)
;   (println! (index-in-env! 'nothing)) => 86
(define (deprioritise! sym)
  (deprioritise-helper! (global-env!) sym '() #f))

(define (index-in-env-helper! sym env i)
  (if (empty? env)
    -1
    (if (= (car (car env)) sym)
      i
      (index-in-env-helper! sym (cdr env) (inc i)))))

; Find the index of a symbol in the global environment.
; Indexing starts at 0. If the symbol could not be found,
; -1 is returned.
(define (index-in-env! sym)
  (index-in-env-helper! sym (global-env!) 0))

;;;;;
;;;;; SECTION: Utilities
;;;;;

; Execute a function with no arguments n times. If n is
; less than 1, the function is still executed at least once.
(define (times n f)
  (if (<= n 1)
    (f)
    (begin
      (f)
      (times (dec n) f))))

; Takes 1 argument and returns it.
(define (id e)
  e)

; Bad, bad, bad
(define (hash-code-helper e)
  (cond ((string? e) (p-hash e))
         ((number? e) (int e))
         ((or (cons? e) (vector? e))
            (foldl
              (lambda (res n) (* res (hash-code n)))
              32 e))
         ((bool? e) (if e 111 -111))
         ((symbol? e) (+ (<< (p-hash (string e)) 1) 1))
         (#t 0)))

; Calculate the hash-code of an object.
(define (hash-code e)
  (let* (code (hash-code-helper e))
    ;(bit-xor code (>> code 10))
    code))

;;;;;
;;;;; SECTION : Tests
;;;;;

(define (range n m acc)
  (if (> n m)
    acc
    (range (inc n) m (vector-append! acc n))))

(let* (v (range 0 100 (vector)))
  (println! (measure 100 (lambda () (filter (lambda (e) (even? e)) v))))
  (let* (l (vector->list v))
    (println! (measure 100  (lambda () (filter (lambda (e) (even? e)) l))))))

(comment

(println! (reverse (list 1 2 3 4 5)))

(println! (hash-code "abc"))
(println! (hash-code 'abc))
(println! (hash-code 198))
(println! (hash-code 891.0))
(println! (hash-code (list 1 2 3 4)))
(println! (hash-code (vector 1 2 3 4 5)))
(println! (hash-code #t))
(println! (hash-code #f))

(let ((v (vector 1 2 3 4 5))
      (nv (cpy-vector v))
      (l (list 1 2 3 4 5))
      (nl (cpy-list l)))
  (println! v)
  (println! nv)
  (vector-append! v 1)
  (println! v)
  (println! nv)
  (println! "")
  (println! l)
  (println! nl)
  (set-car! l 15)
  (println! l)
  (println! nl)
  )

(let* (v (vector 1 2 3 4 5))
  (println! (vector? v))
  (println! (map-vector inc v))
  (println! (filter-vector odd? v))
  (println! (append (vector 1 2 3) (vector 3 4 5)))
  (println! (rest v))
  (println! (foldl + 0 v))
  (println! (even? (vector-get v 1)))
  (println! (even? (vector-get v 4)))
  )

(println! (hash-code 8))
(println! (hash-code "abc"))
(println! (hash-code '()))
(println! (hash-code #t))
(println! (hash-code #f))
(println! (hash-code (vector 1 2 3)))
(println! (hash-code (vector 1 2 (cons 3 4))))
(println! (hash-code (list 1 2 3)))
(println! (hash-code (list 1 2 (cons 3 4))))

(define (add e0 e1) (+ e0 e1))
(println! (add 1 1))
(println! (= 1 1))
(println! (not (= 1 1)))
(println! (not= 1 1))
(println! "")
(println! (= 2 1))
(println! (not (= 2 1)))
(println! (not= 2 1))
(println! "")
(println! (= 1 2))
(println! (not (= 1 2)))
(println! (not= 1 2))

)


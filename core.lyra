(define (load! f)
  (eval! (parse (slurp! f))))

(define require! load!)
(define import! load!)

(define empty? null?)

(define = p=)
(define < p<)
(define > p>)
(define + p+)
(define - p-)
(define * p*)
(define / p/)
(define % p%)
(define & p&)
(define | p|)
(define ^ p^)

(def-macro (and x & xs)
  (if x
    (if (empty? xs)
      x
      (and (first xs) (rest xs)))
    #f))

(def-macro (or x & xs)
  (if x
    #t
    (if (empty? xs)
      #f
      (and (first xs) (rest xs)))))

(define (not x)
  (if x #f #t))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

(define (nth xs index)
  (if xs
    (if (= index 0)
      (car xs)
      (nth (cdr xs) (- index 1)))
    '()))

(define (read!)
  (sread! stdin))

(define (print! s)
  (sprint! stdout s))

(define (println! s)
  (sprint! stdout s)
  (sprint! stdout "\n"))

(define (begin e0 e1)
  (if e0 e1 e1))

(define (map f xs)
  (if (null? xs)
    '()
    (cons (f (car xs)) (map f (cdr xs)))))

(define (map! f xs)
  (if (null? xs)
    xs
    (begin
      (set-car! xs (f (car xs))
      (map! f (cdr xs))))))

(define (filter f xs)
  (if (null? xs)
    '()
    (if (f (car xs))
      (cons (car xs) (filter f (cdr xs)))
      (filter f (cdr xs)))))

(define (foldl f start coll)
  (if (empty? coll)
    start
    (foldl f (f start (first coll) (rest coll)))))

(define (foldr f start coll)
  (if (empty? coll)
    start
    (f (first coll) (foldr f start (rest coll)))))

(def-macro (comment & e)
  )

(println! 15)
(println! (load! "example.lyra"))

(comment Ignore this!)












; Load, parse and execute a lyra-source file
(define (load! f)
  (eval! (parse (slurp! f))))

(define require! load!)
(define import! load!)

; Boolean and
(def-macro (and x y)
  (list 'if x y #f))

; Boolean or
(def-macro (or x y)
  (list 'if x #t y))

; Negate boolean
(define (not x)
  (if x #f #t))

; This macro ignores its body and returns nil.
(def-macro (comment & e)
  )

(define (atom? e)
  (if (null? e) #f
  (if (vector? e) #f
  (if (cons? e) #f #t))))

(define (empty? l)
  (if (vector? l)
    (= (vector-size l) 0)
    (or (atom? l) (null? l))))

(define nil '())

; Operators. These can later be expanded for other types.
; Maybe we could add conses or vectors or strings together?
(define = p=)
(define eq? p=)
(define eql? p=)
(define (not= e0 e1) (not (eq? e0 e1)))
(define < p<)
(define > p>)
(define + p+)
(define - p-)
(define * p*)
(define / p/)
(define % p%)
(define & p&)
(define | p|)
(define ^ p^)
(define << p<<)
(define >> p>>)

(define (max n0 n1) (if (> n0 n1) n0 n1))
(define (min n0 n1) (if (> n0 n1) n1 n0))

; Accessors for conses
(define (first c) (if (vector? c) (vector-get v 0) (car c)))
(define (second c) (if (vector? c) (vector-get v 1) (car (cdr c))))
(define (third c) (if (vector? c) (vector-get v 2) (car (cdr (cdr c)))))
(define (fourth c) (if (vector? c) (vector-get v 3) (car (cdr (cdr (cdr c))))))
(define (rest c) (if (vector? c) (cpy-vector v 1 (dec (vector-size v))) (cdr c)))

; car and cdr variants. Prefer first, second, ... if possible
(define (caar x)    (car (car x)))
(define (cadr x)    (car (cdr x)))
(define (cdar x)    (cdr (car x)))
(define (cddr x)    (cdr (cdr x)))
(define (caaar x)   (car (car (car x))))
(define (caadr x)   (car (car (cdr x))))
(define (cadar x)   (car (cdr (car x))))
(define (caddr x)   (car (cdr (cdr x))))
(define (cdaar x)   (cdr (car (car x))))
(define (cdadr x)   (cdr (car (cdr x))))
(define (cddar x)   (cdr (cdr (car x))))
(define (cdddr x)   (cdr (cdr (cdr x))))
(define (caaaar x)  (car (car (car (car x)))))
(define (caaadr x)  (car (car (car (cdr x)))))
(define (caadar x)  (car (car (cdr (car x)))))
(define (caaddr x)  (car (car (cdr (cdr x)))))
(define (cadaar x)  (car (cdr (car (car x)))))
(define (cadadr x)  (car (cdr (car (cdr x)))))
(define (caddar x)  (car (cdr (cdr (car x)))))
(define (cadddr x)  (car (cdr (cdr (cdr x)))))
(define (cdaaar x)  (cdr (car (car (car x)))))
(define (cdaadr x)  (cdr (car (car (cdr x)))))
(define (cdadar x)  (cdr (car (cdr (car x)))))
(define (cdaddr x)  (cdr (car (cdr (cdr x)))))
(define (cddaar x)  (cdr (cdr (car (car x)))))
(define (cddadr x)  (cdr (cdr (car (cdr x)))))
(define (cdddar x)  (cdr (cdr (cdr (car x)))))
(define (cddddr x)  (cdr (cdr (cdr (cdr x)))))

(define (number? e)
  (or (int? e) (float? e)))

(define (cpy-vector v start end)
  (let* (iter (lambda (i nv)
          (if (> i end)
            nv
            (iter (inc i) (vector-append! nv (vector-get v i))))))
    (iter start (vector))))

(define (vector-each f v)
  (let* (iter (lambda (i)
          (if (= i (vector-size v))
            v
            (begin
              (f (vector-get v i))
              (iter (inc i))))))
    (iter 0)
    v))

(define (vector-reverse-each f v)
  (let* (iter (lambda (i)
          (if (< i 0)
            v
            (begin
              (f (vector-get v i))
              (iter (dec i))))))
    (iter (dec (vector-size v)))
    v))

; Fold left.
(define (vfoldl f start v)
  (let* (iter (lambda (i val)
          (if (= i (vector-size v))
            val
            (iter (inc i) (f val (vector-get v i))))))
    (iter 0 start)))

(define (cfoldl f start coll)
  (if (empty? coll)
    start
    (cfoldl f (f start (first coll)) (rest coll))))

(define (foldl f start coll)
  (if (vector? coll) (vfoldl f start coll) (cfoldl f start coll)))

; Reduce is just an alias for foldl.
(define reduce foldl)

; Fold right
(define (foldr f start coll)
  (if (empty? coll)
    start
    (f (first coll) (foldr f start (rest coll)))))

(define (<= x y) (or (< x y) (= x y)))
(define (>= x y) (or (> x y) (= x y)))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

; Length of cons
(define (length c)
  (if (vector? c)
    (vector-size c)
  (if (cons? c)
    (let* (addone (lambda (n m) (inc n)))
      (foldl addone 0 c))
    0)))

; Get the nth element from a list.
(define (nth xs index)
  (if xs
    (if (= index 0)
      (car xs)
      (nth (cdr xs) (- index 1)))
    '()))

; Read a line from stdin.
(define (read!)
  (sread! stdin))

; Prints a string to stdout.
(define (print! s)
  (sprint! stdout s))

; Prints a string to stdout followed by a new line.
(define (println! s)
  (sprint! stdout s)
  (sprint! stdout "\n"))

; Execute 2 commands in order. The second argument is returned.
(define (begin e0 e1)
  (if e0 e1 e1))

(define (map-vector f v)
  (let* (iter-fn
          (lambda (i nv)
            (if (= (vector-size v) i)
              nv
              (iter-fn (inc i)
                (vector-append! nv (f (vector-get v i)))))))
    (iter-fn 0 (vector))))
  
(define (map-list f xs)
  (if (empty? xs)
    '()
    (cons (f (car xs)) (map f (cdr xs)))))

; Executes a function f on each element of a list xs
; and returns a new list.
(define (map f xs)
  (if (vector? xs)
    (map-vector f xs)
    (map-list f xs)))

; Like map, but works in place.
(define (map! f xs)
  (if (empty? xs)
    xs
    (begin
      (set-car! xs (f (first xs))
      (map! f (rest xs))))))

; Filter a list xs by a predicate f.

(define (filter-vector f v)
  (let* (iter (lambda (i nv)
          (if (>= i (vector-size v))
            nv
            (if (f (vector-get v i))
              (iter (inc i) (vector-append! nv (vector-get v i)))
              (iter (inc i) nv)))))
    (iter 0 (vector))))

(define (filter-list f xs)
  (if (empty? xs)
    '()
    (if (f (car xs))
      (cons (car xs) (filter f (cdr xs)))
      (filter-list f (cdr xs)))))

(define (filter f xs)
  (if (vector? xs) (filter-vector f xs) (filter-list f xs)))

; Returns the last entry of a list.

(define (last-entry cs)
  (if (empty? cs)
    cs
    (if (empty? (cdr cs))
      cs
      (last-entry (cdr cs)))))

; Do not call directly. This should only be called by deprioritise!.
(define (deprioritise-helper! env sym val found)
  (if (empty? env)
    '()
    (if (empty? (cdr env))
      (if found
        (if (= (car (car env)) sym)
          (set-cdr! (car env) val)
          (set-cdr! env (list (cons sym val))))
        '())
      (if (= (car (car env)) sym)
        (if found
          (begin
            (set-car! (car env) (car (cdr env)))
            (set-cdr! (car env) (cdr (cdr env))))
          (let* (v (cdr (car env)))
            (set-car! env (car (cdr env)))
            (set-cdr! env (cdr (cdr env)))
            (deprioritise-helper! (cdr env) sym v #t)))
        (deprioritise-helper! (cdr env) sym val found)))))

; Find symbol in global env and move it to the end
; Example:
;   (define nothing '())
;   (println! (index-in-env! 'nothing)) => 0
;   (deprioritise! 'nothing)
;   (println! (index-in-env! 'nothing)) => 86
(define (deprioritise! sym)
  (deprioritise-helper! (global-env!) sym '() #f))

(define (index-in-env-helper! sym env i)
  (if (empty? env)
    -1
    (if (= (car (car env)) sym)
      i
      (index-in-env-helper! sym (cdr env) (inc i)))))

; Find the index of a symbol in the global environment.
; Indexing starts at 0. If the symbol could not be found,
; -1 is returned.
(define (index-in-env! sym)
  (index-in-env-helper! sym (global-env!) 0))

; Prints the elements of a list, separated by newlines.
(define (printall! cs)
  (if (empty? cs)
    '()
    (begin
      (println! (car cs))
      (printall! (cdr cs)))))

; Execute a function with no arguments n times. If n is
; less than 1, the function is still executed at least once.
(define (times n f)
  (if (<= n 1)
    (f)
    (begin
      (f)
      (times (dec n) f))))

; Appends a list to another.
; The complexity depends on the length of the first list.
(define (append-list c0 c1)
  (if (empty? c0)
    c1
    (cons (first c0) (append-list (rest c0) c1))))

; Appends a vector to another.
(define (vector-append-multi v0 v1)
  (let* (iter (lambda (i nv)
          (if (= i (vector-size v1))
            nv
            (iter (inc i) (vector-append! nv (vector-get v1 i))))))
    (iter 0 (cpy-vector v0 0 (dec (vector-size v0))))))

(define (append c0 c1)
  (if (vector? c0)
    (vector-append-multi c0 c1)
    (append-list c0 c1)))
    
(define (reverse-list xs)
  (foldl cons '() xs))

(define (reverse-vector v)
  (let*))

(define (even? n)
  (= (% n 2) 0))

(define (odd? n)
  (not= (% n 2) 0))

(define (list->vector ls)
  (foldl (lambda (v x) (vector-append! v x))
         (vector) ls))

(define (vector->list v)
  (let* (iter (lambda (i nl)
          (if (< i 0)
            nl
            (iter (dec i)
              (cons (vector-get v i) nl)))))
    (iter (dec (vector-size v)) '())))

(define (id e)
  e)

; Bad, bad, bad
(define (hash-code e)
  (if (string? e)
    (hash e)
  (if (number? e)
    e
  (if (or (cons? e) (vector? e))
    (foldl
      (lambda (res n) (* res (hash-code n)))
      32 e)
  (if (bool? e)
    (if e 111 -111)
    0)))))

;;;
; Tests from here.
;;;

(comment

(let* (v (vector 1 2 3 4 5))
  (println! (vector? v))
  (println! (map-vector inc v))
  (println! (filter-vector odd? v))
  (println! (append (vector 1 2 3) (vector 3 4 5)))
  (println! (rest v))
  (println! (foldl + 0 v))
  (println! (even? (vector-get v 1)))
  (println! (even? (vector-get v 4)))
  )

(println! (hash-code 8))
(println! (hash-code "abc"))
(println! (hash-code '()))
(println! (hash-code #t))
(println! (hash-code #f))
(println! (hash-code (vector 1 2 3)))
(println! (hash-code (vector 1 2 (cons 3 4))))
(println! (hash-code (list 1 2 3)))
(println! (hash-code (list 1 2 (cons 3 4))))

(define (add e0 e1) (+ e0 e1))
(println! (add 1 1))
(println! (= 1 1))
(println! (not (= 1 1)))
(println! (not= 1 1))
(println! "")
(println! (= 2 1))
(println! (not (= 2 1)))
(println! (not= 2 1))
(println! "")
(println! (= 1 2))
(println! (not (= 1 2)))
(println! (not= 1 2))

)


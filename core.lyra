
; Load, parse and execute a lyra-source file
(define (load! f)
  (eval! (parse (slurp! f))))

(define require! load!)
(define import! load!)

; This macro ignores its body and returns nil.
(def-macro (comment & e)
  )

(define empty? null?)
(define nil '())

; Operators. These can later be expanded for other types.
; Maybe we could add conses or vectors or strings together?
(define = p=)
(define eq? p=)
(define eqlÂ´? p=)
(define < p<)
(define > p>)
(define + p+)
(define - p-)
(define * p*)
(define / p/)
(define % p%)
(define & p&)
(define | p|)
(define ^ p^)
(define << p<<)
(define >> p>>)

; Accessors for conses
(define first car)
(define (second c) (car (cdr c)))
(define (third c) (car (cdr (cdr c))))
(define (rest c) (cdr c))

; Fold left.
(define (foldl f start coll)
  (if (empty? coll)
    start
    (foldl f (f start (first coll)) (rest coll))))

; Reduce is just an alias for foldl.
(define reduce foldl)

; Fold right
(define (foldr f start coll)
  (if (empty? coll)
    start
    (f (first coll) (foldr f start (rest coll)))))

; Boolean and
(def-macro (and x y)
  (list 'if x y #f))

; Boolean or
(def-macro (or x y)
  (list 'if x #t y))

; Negate boolean
(define (not x)
  (if x #f #t))

(define (<= x y) (or (< x y) (= x y)))
(define (>= x y) (or (> x y) (= x y)))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

; Length of cons
(define (length c)
  (let* (addone (lambda (n m) (inc n)))
    (foldl addone 0 c)))

; Get the nth element from a list.
(define (nth xs index)
  (if xs
    (if (= index 0)
      (car xs)
      (nth (cdr xs) (- index 1)))
    '()))

; Read a line from stdin.
(define (read!)
  (sread! stdin))

; Prints a string to stdout.
(define (print! s)
  (sprint! stdout s))

; Prints a string to stdout followed by a new line.
(define (println! s)
  (sprint! stdout s)
  (sprint! stdout "\n"))

; Execute 2 commands in order. The second argument is returned.
(define (begin e0 e1)
  (if e0 e1 e1))

; Executes a function f on each element of a list xs
; and returns a new list.
(define (map f xs)
  (if (null? xs)
    '()
    (cons (f (car xs)) (map f (cdr xs)))))

; Like map, but works in place.
(define (map! f xs)
  (if (null? xs)
    xs
    (begin
      (set-car! xs (f (car xs))
      (map! f (cdr xs))))))

; Filter a list xs by a predicate f.
(define (filter f xs)
  (if (null? xs)
    '()
    (if (f (car xs))
      (cons (car xs) (filter f (cdr xs)))
      (filter f (cdr xs)))))

; Returns the last entry of a list.
(define (last-entry cs)
  (if (empty? cs)
    cs
    (if (empty? (cdr cs))
      cs
      (last-entry (cdr cs)))))

; Do not call directly. This should only be called by deprioritise!.
(define (deprioritise-helper! env sym val found)
  (if (empty? env)
    '()
    (if (empty? (cdr env))
      (if found
        (if (= (car (car env)) sym)
          (set-cdr! (car env) val)
          (set-cdr! env (list (cons sym val))))
        '())
      (if (= (car (car env)) sym)
        (if found
          (begin
            (set-car! (car env) (car (cdr env)))
            (set-cdr! (car env) (cdr (cdr env))))
          (let* (v (cdr (car env)))
            (set-car! env (car (cdr env)))
            (set-cdr! env (cdr (cdr env)))
            (deprioritise-helper! (cdr env) sym v #t)))
        (deprioritise-helper! (cdr env) sym val found)))))

; Find symbol in global env and move it to the end
; Example:
;   (define nothing '())
;   (println! (index-in-env! 'nothing)) => 0
;   (deprioritise! 'nothing)
;   (println! (index-in-env! 'nothing)) => 86
(define (deprioritise! sym)
  (deprioritise-helper! (global-env!) sym '() #f))

(define (index-in-env-helper! sym env i)
  (if (empty? env)
    -1
    (if (= (car (car env)) sym)
      i
      (index-in-env-helper! sym (cdr env) (inc i)))))

; Find the index of a symbol in the global environment.
; Indexing starts at 0. If the symbol could not be found,
; -1 is returned.
(define (index-in-env! sym)
  (index-in-env-helper! sym (global-env!) 0))


; Prints the elements of a list, separated by newlines.
(define (printall! cs)
  (if (empty? cs)
    '()
    (begin
      (println! (car cs))
      (printall! (cdr cs)))))

; Execute a function with no arguments n times. If n is
; less than 1, the function is still executed at least once.
(define (times n f)
  (if (<= n 1)
    (f)
    (begin
      (f)
      (times (dec n) f))))

; Appends a list to another.
; The complexity depends on the length of the first list.
(define (append c0 c1)
  (if (empty? c0)
    c1
    (cons (car c0) (append (cdr c0) c1))))

;;;
; Tests from here.
;;;

; Here for testing.
(define (range n m res)
  (if (= n m)
    res
    (range (inc n) m (cons n res))))

;(println! (list 1 2 3 4 5))
;(println! (plen (list 1 2 3 4 5)))
;(println! (length3 (list 1 2 3 4 5) 0))
;(println! (cons? (list 1 2 3 4 5)))
;(println! (if (not (cons? (list 1 2 3 4 5))) 0 (inc 1)))

(define (fib n a b)
  (if (= n 0) a
  (if (= n 1) b
  (fib (dec n) b (+ a b)))))

(define (fib2 n)
  ;(println! (length (call-stack!)))
  (if (< n 2)
    n
    (+ (fib2 (dec n)) (fib2 (- n 2)))))

;(println! (fib 20 0 1))
;(println! (fib2 20))

(println! (time!))
(let* (longvar (range 0 250000 '()))
  (println! (time!))
  (println! (length longvar))
  (println! (measure 1 (lambda () (length longvar)))))

(comment

;(println! (+ "Rrsult: " (string (fib2 25))))
;(println! (measure 1 (lambda () (fib 25 0 1))))
;(println! (measure 1 (lambda () (fib2 25))))


(println! (measure 1
  (lambda ()
    (let* (longvar (range 0 2500000))
      (println! (measure 10 (lambda () (length longvar))))
      (println! (measure 10 (lambda () (length2 longvar))))))))

(let* (longvar (range 0 2500000))
  (println!
    (measure 10
      (lambda ()
        (length longvar)
        (length longvar)
        (length longvar)
        (length longvar)
        (length longvar)))))

(println!
  (measure 10
    (lambda ()
      (last-entry (global-env!)))))

(println!
  (times
    10
    (lambda ()
      (last-entry (global-env!)))))

; Thanks to tail-recursion, this will not actually crash.
(define (crash)
  (crash))

(times
  100
  (lambda () '()))
)





